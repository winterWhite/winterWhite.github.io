[{"title":"Design Articles","url":"/2018/08/29/Design-Articles/","content":"\n# 7 principles for button design\n\n## Make buttons look like buttons\n\n- Don’t assume that something in your UI is obvious for your users\n- Use familiar designs for your buttons\n    - Filled button with square borders\n    - Filled button with rounded corners\n    - Filled button with shadows [Most Useful]\n    - Ghost button\n- Don’t forget about the whitespace\n\n## Put buttons where users expect to find them\n\n- Use traditional layouts and standard UI patterns as much as possible\n- Don’t play hunt-the-button game with your users\n\n## Label buttons with what they do\n\n- Button’s label should clearly describe its action\n- Never designed a dialog box or form that consisted solely of the two buttons ‘OK’ and ‘Cancel’\n\n## Properly size your buttons\n\n- Prioritize buttons: Large Size or Contrasting Color\n- Make buttons finger-friendly for mobile users [MIT Touch Lab study found that averages for finger pads are between 10–14mm and fingertips are 8–10mm. This makes 10mm x 10mm a good minimum touch target size.]\n\n## Mind the order\n\n- The order for buttons should reflect the nature of a conversation between the user and the system\n- User interface is a conversation with your users\n\n## Avoid using too many buttons\n\n- Think about the most important actions you want your users to take\n\n## Provide visual or audio feedback on interaction\n\n- When users don’t have any feedback, they might consider that the system didn’t receive their command and will repeat the action. \n- For some options, it’s worth not only acknowledging user input but also show a current state of the process.\n\n# 7 Practical Tips for Design\n\n## Use color and weight to create hierarchy instead of size\n\n- Try and stick to two or three colors\n    - A dark (but not black) color for primary content\n    - A grey for secondary content\n    - A lighter grey for ancillary content\n- Two font weights is usually enough for UI work\n    - A normal font weight (400 or 500 depending on the font) for most text\n    - A heavier font weight (600 or 700) for text you want to emphasize\n    - Stay away from font weights under 400 for UI work\n    \n## Don’t use grey text on colored backgrounds\n\nMaking the text closer to the background color is what actually helps create hierarchy, not making it light grey\n\nText work with colorful background: \n\n- Reduce the opacity of white text, Use white text and lower the opacity\n- Hand-pick a color that’s based on the background color [This works better than reducing the opacity when your background is an image or pattern]\n\n## Offset your shadows\n\nInstead of using large blur and spread values to make box shadows more noticeable, add a vertical offset. It looks a lot natural.  \n\nMaterial Design: <https://material.io/design/environment/elevation.html>\n\n## Use fewer borders\n\nInstead using border to distinguish two elements from one another, try some more methods. Because too much borders makes your design feel busy and cluttered.\n\n- Use a box shadow [more subtle and accomplish]\n- Use two different background colors [Giving adjacent elements slightly different background colors]\n- Add extra spacing [Spacing things further apart is a great way to create distinction between groups of elements]\n\n## Don’t blow up icons that are meant to be small\n\nIcons that were drawn at 16–24px are never going to look very professional when you blow them up to 3x or 4x their intended size.\n\nIf small icons are all you’ve got, try enclosing them inside another shape and giving the shape a background color, This lets you keep the actual icon closer to its intended size, while still filling the larger space.\n\nsome icon website:\n\n- <https://fontawesome.com/>\n- <http://www.zondicons.com/>\n- <http://www.heroicons.com/>\n- <https://useiconic.com/>\n\n## Use accent borders to add color to a bland design\n\nIt's a simple way to make your design more \"designed\"\n\n<https://dribbble.com/colors/e3c0ac>\n\n## Not every button needs a background color\n\nWhen designing actions, it’s important to communicate their place in the hierarchy.\n\n- Primary actions should be obvious. [Solid, high contrast background colors work great here.]\n- Secondary actions should be clear but not prominent. [Outline styles or lower contrast background colors are great options.]\n- Tertiary actions should be discoverable but unobtrusive. [Styling these actions like links is usually the best approach.]\n\n# Form Design For HTML5\n\n<https://www.smashingmagazine.com/2018/08/ux-html5-mobile-form-part-1/?utm_source=mobiledevweekly&utm_medium=email>\n\n# Color Design\n\n<https://uxplanet.org/bright-colors-in-ui-design-benefits-and-drawbacks-433680f0a1c7>\n\n# 书单\n\n<https://docs.google.com/spreadsheets/d/11R5U4v__YNqPcENM7ui2OsUK7hLWLlEKg6H8yaO8us8/edit#gid=0>\n\n# How to be a UX／UI Designer\n\n<https://blog.nicolesaidy.com/7-steps-to-become-a-ui-ux-designer-8beed7639a95>\n\n<https://uxplanet.org/12-mobile-ux-design-trends-for-2018-5b4ce7e8445f>","tags":["Design"]},{"title":"CSS System","url":"/2018/08/29/CSS-System/","content":"\n## Some Css Action\n\n- Naming conventions 命名约定\n- BEM, SMACSS\n- CSS style sheet language extension\n- CSS Modules with React\n- Sass，Less\n- File architecture 文件结构\n- Atomic CSS, ITCSS\n- CSS frameworks，Bootstrap\n- Javascript frameworks，React、Vue、Angular\n\n## CSS Course\n\n- CSS Grid：<https://scrimba.com/g/gR8PTE>","tags":["CSS"]},{"title":"React Advanced Reading","url":"/2018/08/24/React-Advanced-Reading/","content":"\n# React 进阶学习系列\n\n## Context\n\n**应用场景**：数据需要在**不同嵌套层级**且**多个组件**间复用时\n\n### 组成\n基于生产者消费者模式：\n\n1. Provider\n2. Consumer\n\n\n### Component composition\n\n（PS：如果只是想解决多层级传递props的问题，推荐使用 Component composition）\n\n## HOCs\n\n## Refs & Dom\n\n## Testing\n\n# Redux Learning\n\nResource: <https://egghead.io/courses/getting-started-with-redux>","tags":["React"]},{"title":"Beatiful Library","url":"/2018/08/23/Beatiful-Library/","content":"\n## CSS\n\n- Semantic UI: <https://semantic-ui.com/>\n- CSS property 一览表：<https://css-tricks.com/almanac/>\n- Some Interesting Pure Css Animation: <https://webdesign.tutsplus.com/articles/pure-css-animation-inspiration-on-codepen--cms-30875>\n- Hover, an Css animation library: <http://ianlunn.github.io/Hover/>\n- Pure Css: <https://purecss.io/>\n\n## JS\n\n- Anime animation library: <http://animejs.com/>\n- Lottie mobile animation library: <http://airbnb.io/lottie/>\n- React Native Components Library: <https://react-native-training.github.io/react-native-elements/docs/0.19.0/avatar.html>\n- React-based charts react-vis: <https://uber.github.io/react-vis/examples/showcases/misc>\n\n## Utility JS Library\n\n- lodash\n- functional programing —— Ramda <https://github.com/ramda/ramda>\n- Moment 替代品(Date-fns)\n- MathJS\n- Lazy <https://github.com/dtao/lazy.js>\n- ChanceJS 随机数生成器，use for testing\n- ChartJS H5 图标库，基于 canvas\n\n## Design \n\n- <https://refactoringui.com/>","tags":["Library"]},{"title":"10 Principles for FE Developer","url":"/2018/08/20/10-Principles-for-FE-Developer/","content":"\n## Divide and conquer 分而治之\n\n## Semanticization 语义化命名 \n\n## Avoid magic numbers or strings \n\nPut it into a variable with a meaningful name and move it to the top of its scope.\n\n## Fight nesting\n\n超过 500 行的代码、嵌套超过 3 层的代码，都需要分割重构！\n\n## Configure hard 配置分离管理\n\nIf your application uses global values, API endpoints, feature toggles, or third-party credentials³ — put those in a separate config file.\n\n## Frameworks are there to help 选择合适的框架\n\n- React：需要良好的规划，Will Payback A Lot\n- Angular / VueJS / Ember：消除架构规划的优缺点、黑盒\n- jQuery / lodash / or similar：缩短开发时间，更多作为辅助，Not 基础\n- Pure JavaScript ：大量时间，计划\n\n## Unless it is a prototype — write tests 测试\n\nUnit tests. Smoke tests. End-to-end tests\n\n## Use version control 版本控制\n\n## Manage state responsibly 状态管理\n\nReact：\n\n- Redux for Flux\n- Mobx for Observable\n\nAngular, Ember, and VueJS：\n\n- Built in based on Observable\n- Vuex、ngRx\n\n## Question trends 质疑精神","tags":["FrontEnd"]},{"title":"Web Design Sources","url":"/2018/08/20/Web-Design-Sources/","content":"\n- <https://medium.freecodecamp.org/a-developers-guide-to-web-design-for-non-designers-1f64ce28c38d>","tags":["Design"]},{"title":"JavaScript Errors","url":"/2018/08/20/JavaScript-Errors/","content":"\n# Top 10 JavaScript Errors\n\n## Uncaught TypeError: Cannot read property\n\nError In Chrome\n\n**Mostly Cause By** Improper (不合时宜的) initialization of state while rendering the UI components;   \n**Deal With** Initialize state with reasonable default values in the constructor.\n\n## TypeError: ‘undefined’ is not an object\n\nSame as First one，Error In Safari\n\n## TypeError: null is not an object\n\nError In Safari\n\nThis is not same as last two errors，see：\n\n1. Undefined is usually a variable that has not been assigned\n2. Null means the value is blank\n\n**May Cause By** Try using a DOM element in JavaScript before the element is loaded;   \n**Deal With** Make sure executes and deals with DOM elements after the DOM elements have been created.\n\n## (Unknown): Script error\n\nOccurs when an uncaught JavaScript error crosses domain boundaries in violation of the cross-origin policy.\n\nTo Get Useful Information: \n\n1. Send the Access-Control-Allow-Origin header, Set * or your domain\n2. Set crossorigin=”anonymous” on the script tag\n\n## TypeError: Object doesn’t support property\n\nError In IE\n\n**May Cause By** IE’s inability to bind methods within the current namespace to the this keyword;   \n**Deal With** Using JS namespacing is to always prefix with the actual namespace.\n\nExample:\n````\nthis.isAwesone() => Rollbar.isAwesone()\n````\n\n## TypeError: ‘undefined’ is not a function\n\nError In Chrome\n\n**May Cause By** Self-referencing scopes within callbacks and closures confusion;   \n**Deal With** \n\n1. Save your reference to this in a variable that can then be inherited by the closure\n2. Use the bind() method to pass the proper reference\n\n## Uncaught RangeError: Maximum call stack\n\nError In Chrome\n\n**Cause By**\n\n1. Call a recursive (递归) function that does not terminate\n2. Pass a value to a function that is out of range\n\n## TypeError: Cannot read property ‘length’\n\nError In Chrome\n\n**Cause By** Reading length property for an undefined variable:\n\n1. Array is not initialized\n2. Variable name is hidden in another context\n\n## Uncaught TypeError: Cannot set property\n\nError In Chrome\n\n**Cause By** Try to access an undefined variable\n\n## ReferenceError: event is not defined\n\nError In Chrome\n\n**Cause By** Try to access a variable that is undefined or is outside the current scope.\n\n## Summary\n\nUsing TypeScript Make You More Safety!","tags":["JavaScript"]},{"title":"Career-Learning","url":"/2018/08/17/Career-Learning/","content":"\n## Front End\n\n![FrontEnd Learning RoadMap](/imgs/frontend.png)\n\n\n## Back End\n\n![BackEnd_Learning_RoadMap](/imgs/backend.jpg)\n\n### 2nd 2018\n\n![BackEnd Learning RoadMap 2](/imgs/backend2.png)\n\n\n## Devops\n\n![Devops_Learning_RoadMap](/imgs/devops.png)\n\n\n## React Dev\n\n![React_Learning_RoadMap](/imgs/react.png)\n\n## Game Dev\n\n![Game Dev Intro](/imgs/game-dev-intro.png)\n\n### Client\n\n![Game Dev Client WIP](/imgs/game-dev-client-wip.png)\n\n![Game Dev Client](/imgs/game-dev-client.png)\n\n### Server\n\n![Game Dev Server](/imgs/game-dev-server.png)","tags":["Career"]},{"title":"Node Learning Resource","url":"/2018/08/16/Node-Learning-Resource/","content":"\n两个star比较高的 Node.js 学习仓库资料\n\n## Node 包教不包会\n\ngithub 地址：<https://github.com/alsotang/node-lessons>\n\n\n## 一起学 Node.js\n\ngithub 地址：<https://github.com/nswbmw/N-blog>","tags":["Node.js"]},{"title":"Learn Algorithms & Data structure","url":"/2018/08/15/Learn-Algorithms-Data-structure/","content":"\n**原文链接**：<https://medium.com/coderbyte/how-to-get-good-at-algorithms-data-structures-d33d5163353f>\n\n## Basic 基础\n\n1. Math and Logic 数学知识集合\n    - Set theory 集合\n    - Finite-state machines 有限状态机\n    - Regular expressions 正则表达式\n    - Matrix multiplication 矩阵乘法\n    - Bitwise operations 位运算\n    - Linear equations 线性方程\n    - Important combinatorics concepts 组合概念\n        - Permutations 排列\n        - Combinations 组合\n        - Pigeonhole principle 鸽子原理\n    - Geometry 几何学\n2. Computer Architecture 计算机知识\n    - Boolean algebra 布尔代数\n    - Computer arithmetic 计算机算数\n    - Floating-point representation 浮点表示\n    - Cache design 缓存设计\n    - C 语言 and 汇编语言\n    \n    \n## Advanced 进阶\n\n1. Big-O & Runtime: <https://github.com/tayllan/awesome-algorithms#online-courses>\n2. Some Algorithms\n    - Binary search 二进制搜索\n    - Euclid’s algorithm 欧几里得算法\n    - Depth and breadth first search 深度和广度优先算法\n    - Dijkstra’s shortest path 最短路径算法\n    - Binary tree traversals 二叉树遍历\n    - Insertion sort, Merge sort, Quick sort 插入排序／合并排序／快速排序\n    - Min & max heaps 最小／最大堆\n    - <https://hbfs.wordpress.com/2008/12/23/the-10-classes-of-algorithms-every-programmer-must-know-about/>\n3. Read Some Books: <https://www.amazon.com/Algorithm-Design-Manual-Steven-Skiena/dp/1849967202>\n4. Challenges: <https://medium.freecodecamp.org/the-10-most-popular-coding-challenge-websites-of-2016-fb8a5672d22f>\n5. Dynamic Programming","tags":["FullStack"]},{"title":"构建系列-Webpack","url":"/2018/08/14/Build-Webpack/","content":"\nWebpack 是一个打包模块化的JavaScript的工具，专注于构建模块化的项目。   \nWebpack 通过 loader 转换文件，通过Plugin 注入钩子，最后输出由多个模块组合成的文件。\n\n## Webpack 的工作\n\n![Webpack work](/imgs/webpack-do.svg)\n\n## JS 的转换处理\n\n1. 转换成可执行的JS，如 vue-loader、ts-loader\n2. 支持新特性，babel-loader\n\n\n## CSS 的转换处理\n\n1. CSS 预处理，如 postcss-loader\n2. CSS & 基础，css-loader、style-loader\n\n\n## 其它文件，如 png、jpg、svg、ttf\n\n1. file-loader\n2. url-loader\n\n## 一些教程链接\n\n- 阮一峰 webpack 系列 demo：<https://github.com/ruanyf/webpack-demos#demo01-entry-file-source>\n- webpack 4 系列教程：<https://www.valentinog.com/blog/webpack-tutorial/>\n- webpack 解惑：<https://medium.com/@rajaraodv/webpack-the-confusing-parts-58712f8fcad9>","tags":["Build"]},{"title":"If You Want To Be A Designer","url":"/2018/08/14/If-You-Want-To-Be-A-Designer/","content":"\n一些牛逼的设计者博客，文章链接集合\n\n- 100 天矢量动画设计：<https://uxdesign.cc/100-days-of-motion-design-463526af852f>\n- 100 天矢量图设计：<https://medium.com/the-100-day-project/100-days-of-vector-illustration-6f2f10209b0b>\n- 100 天刻字设计：<https://medium.com/the-100-day-project/100-days-of-lettering-a2b01ade996f>\n- 100 天涂鸦计划：<https://medium.com/the-100-day-project/100-days-of-doodle-982391750edd>\n","tags":["Design"]},{"title":"Understand Git","url":"/2018/08/13/Understand-Git/","content":"\n## Git 是一个文件夹\n此文件夹即 .git 文件夹，而克隆一个仓库的本质，就是复制 .git\n\n## Git 是一个数据库\nGit 是一个简单的 key-value 数据仓库，数据存储位置 .git/objects\n\n## 树 (Tree) 是一个内部组件\n\n## Index 是安装树的地方\n","tags":["Git"]},{"title":"State Management","url":"/2018/08/13/State-Management/","content":"\n来自文章《如何直观的在JavaScript中管理状态》\n\n好的状态管理原则：   \n\n1. 区分不确定数据和有限状态 —— 限制从一个状态到另一个状态转换的可能性\n2. 设计直观\n\n8个要点： \n  \n1. 状态不等于数据   \n**状态**表示系统可以处于有限数量的模式下，状态是可数的。   \n**数据**储存在具有几乎有无限可能的存储器中，数据是无限可能的。   \n分离状态和数据可以减少混淆，并允许我们构建基于有限状态机的应用。\n2. 状态有限   \n一个可预测的界面一定是具有有限和可控状态数量的状态。在有限状态机中，状态是被明确定义的。   \n**转换**是一组可以进行状态转移事件的集合。\n3. 管理状态机的复杂度   \n需要注意不同状态间不受控制的转换\n4. 守卫转换   \n**守卫**是状态转换发生所必需要满足的条件。\n5. 状态是图   \n状态理想的数据结构通常是图。\n6. 状态图脚手架   \n状态图应当成为开发应用的脚手架。\n7. statecharts：减轻状态图的复杂度   \n状态类型：初始状态、嵌套状态、并行状态、历史状态   \n其它：转换、守卫、行为\n8. statecharts 工具\n","tags":["JavaScript"]},{"title":"Software Architectural Pattern","url":"/2018/08/13/Software-Architectural-Pattern/","content":"\n## Layered pattern 分层模式\n\n基础分层：\n1. Presentation layer (UI layer) 表现层\n2. Application layer (Service layer) 应用层\n3. Business logic layer (Domain layer) 业务层\n4. Data access layer (Persistence layer) 数据层\n\n应用场景：\n1. General desktop applications 桌面应用程序\n2. E commerce web applications 电子商务 Web 应用\n\n示意图：\n\n![Layered pattern](/imgs/architectural-pattern-layered.png)\n\n\n## Client-server pattern 客户端／服务器模式\n\n服务器监听客户端的所有请求，并进行响应\n\n应用场景：\n1. Online applications 线上应用，如 email、banking\n\n示意图：\n\n![Client-server pattern](/imgs/architectural-pattern-c-s.png)\n\n\n## Master-slave pattern 主从模式\n\nMaster 分发工作到 Slaves 的工作模式\n\n应用场景：\n1. Database replication 数据库复制中的主数据库和从属数据库\n2. Master and Slave drives 主／从驱动器\n\n示意图：\n\n![Master-slave pattern](/imgs/architectural-pattern-m-s.png)\n\n\n## Pipe-filter pattern 管道过滤器模式\n\n数据 filtering 模式\n\n应用场景：\n1. Compilers 编译器\n2. Workflows in bioinformatics 生物信息学工作流程\n\n示意图：\n\n![Pipe-filter pattern](/imgs/architectural-pattern-p-f.png)\n\n\n## Broker pattern 经纪人模式\n\n分布式系统，服务端-代理-客户端模式\n\n应用场景：\n1. Message broker software 消息代理软件，如 Apache Kafka\n\n示意图：\n\n![Broker pattern](/imgs/architectural-pattern-broker.png)\n\n\n## Peer-to-peer pattern 点对点模式\n\n对等体，同时具有服务端／客户端的角色功能，可动态切换\n\n应用场景：\n1. File-sharing networks 文件共享网络，如 G2\n2. Multimedia protocols 多媒体协议，如 P2PTV\n\n示意图：\n\n![Peer-to-peer pattern](/imgs/architectural-pattern-p2p.png)\n\n\n## Event-bus pattern 事件总线模式\n\n事件的4个组成部分：Event Source 事件源、Event Listener 事件监听器、Channel 通道、Event Bus 事件总线\n\n应用场景：\n1. Android development 安卓开发\n2. Notification services 通知服务\n\n示意图：\n\n![Event-bus pattern](/imgs/architectural-pattern-e-b.png)\n\n\n## Model-view-controller pattern 模型-视图-控制器模式 (MVC)\n\n3个组成部分：\n1. Model: Core functionality and data\n2. View: Displays the information to the user\n3. Controller: Handles the input from the user\n\n解耦数据与用户展示\n\n应用场景：\n1. World Wide Web applications 万维网应用架构\n2. Web frameworks Web 框架，如 Rails\n\n示意图：\n\n![Model-view-controller pattern](/imgs/architectural-pattern-mvc.png)\n\n\n## Blackboard pattern 黑板模式\n\n3个组成部分：\n1. blackboard \n2. knowledge source\n3. control component\n\n应用场景：\n1. Speech recognition 语音识别\n2. Vehicle identification and tracking 车辆识别与跟踪\n3. Protein structure identification 蛋白质结构鉴定\n4. Sonar signals interpretation 声纳信号解释\n\n示意图：\n\n![Blackboard pattern](/imgs/architectural-pattern-blackboard.png)\n\n\n## Interpreter pattern 口译员模式\n\n为语言的每个符号设定一个类，解释专用语言编写的程序组件\n\n应用场景：\n1. Database query languages 数据库语言，如 SQL\n2. Languages used to describe communication protocols 描述通信协议的语言\n\n示意图：\n\n![Interpreter pattern](/imgs/architectural-pattern-Interpreter.png)\n\n\n## Compare 对比\n\n![Compare architectural pattern](/imgs/architectural-pattern-compare.png)\n\n","tags":["BackEnd"]},{"title":"Continuous Delivery","url":"/2018/08/13/Continuous-Delivery/","content":"\n# 《持续交付-发布可靠软件的系统方法》\n\n===================== **基础** ===============================\n\n## Part 1 基础篇\n\n### 软件交付的问题\n\n**关键词**：\n部署流水线：构建 => 部署 => 测试 => 发布\n自动化、持续集成\n\n**发布反模式**\n1. 手工部署\n2. 开发完成之后才向类生产环境部署\n3. 生产环境的手工配置管理\n\n**关键词**：短周期【决定变更～用户可用】、高质量【质量不等于完美】\n反馈：\n1. 无论什么样的修改都应该触发反馈流程\n2. 反馈应该尽快发出\n3. 交付团队必须接受反馈，并依据它做出相应的行动\n\n可工作的软件组成：可执行的代码、配置信息、运行环境、数据\n\n**软件交付原则**\n1. 为软件发布创建一个**可重复**且**可靠**的过程\n\t1. 尽可能地自动化\n\t2. 尽可能将所有东西纳入版本控制\n2. 内建质量：尽早发现问题，解决问题，提前并频繁地做让你感到痛苦的事\n3. DONE意味着“已发布”\n4. 交付过程事每个成员的责任\n5. 持续改进: 计划plan => 做do => 研究stydy => 行动act\n\n\n## Part 2 配置管理\n\n### 定义\n**配置管理**：配置管理是指一个过程，通过该过程，所有与项目相关的产物，以及它们之间的关系都被**唯一**定义、修改、存储和检索\n\n### 版本控制\n**版本控制系统**：也称源代码控制管理系统或修订控制系统，是保存文件多个版本的一种机制。example：SCCS、RCS、CVS、Subversion、Mercurial、Git...\n\n**版本控制的目的**\n1. 保留每个文件的所有版本的历史信息，并使之易于查找\n2. 让分布式团队可以愉快地协作\n\n#### 与项目相关的所有东西都纳入版本控制\n**目标**：能够随时获取软件在整个生命周期中任意时间点的文件状态【编译后的二进制代码不需要】\n\n#### 频繁提交\n1. 只有频繁提交代码，才能享受版本控制带来的好处\n2. 一旦将代码提交，团队的所有人都能看到这些变更\n3. 一次提交出发一次构建集成\n\n提交需要确保不破坏原有系统：\n1. 提交代码前运行测试套件\n2. 增量式引入变化\n\n当进行某项复杂的工作时，如何保证频繁提交的同时又不破坏原有系统？\n\n**不推荐开分支的原因**\n1. 违背了持续集成的宗旨，新分支推迟了新功能的整合，只有到分支被合并时才能发现集成问题\n2. 多个开发者分别创建分支，问题会程指数增加，合并过程也会极其复杂\n3. 尽管又好用的自动合并功能，但它无法解决语义冲突\n4. 合并困难导致重构代码库变得困难\n\n我们推荐使用**增量方式**开发新功能，并频繁且有规律地向版本控制系统提交代码。\n\n#### 提交注释\n推荐的提交注释：第一段简短地总结性描述；接下来描述更多细节；包含一个可以链接到项目管理工具中的一个功能或缺陷的链接\n\n### 依赖管理\n1. 外部库文件\n2. 组件管理\n\n### 软件配置管理\n配置反模式：终级配置，系统配置工作变得非常复杂以至于抵消了其在灵活性上带来的好处\n**更好的方式**：先专注于提供具有高价值且可配置程度较低的功能，然后在真正需要时再添加可配置选项\n\n#### 配置分类\n1. 构建时\n2. 打包时\n3. 部署软件程序时\n4. 启动／运行时\n建议：在相邻的两次部署之间，任何变更都应该作为配置项被捕获和记录，而不应该在编译或打包时植入\n\n#### 应用程序配置管理\n特定于测试环境或生产环境的实际配置信息应该与源代码分离在单独的代码库中。需要保证配置信息的版本与相应的应用软件的版本相匹配。\n\n1. 获取配置信息\n\t1. 中央服务系统提供配置信息\n\t2. 中心仓库获取配置信息\n2. 配置项建模\n3. 系统配置测试\n\t1. 保证配置设置中对外部服务的饮用是良好的\n\t2. 冒烟测试\n\n**跨应用配置管理**：配置选项索引表、实时存取配置信息\n\n#### 管理配置信息的原则\n将应用程序的配置信息当作代码一样来看待 \n1. 明确配置注入时机\n2. 配置项与代码同一个仓库保存，但配置值单独保存\n3. 自动化\n4. 容易查看\n5. 明确命名\n6. 模块化 and 封闭\n7. DRY 原则\n8. 最少化\n9. 避免过度设计，应尽可能简单\n10. 测试\n\n### 环境管理\n**环境**：应用程序所以来的硬件、软件、基础设施和外部系统\n**原则**：环境的配置和应用程序的配置同样重要\n**内容**\n1. 操作系统，包括其版本、补丁级别以及配置设置\n2. 软件包，及软件包的具体版本和配置\n3. 网络拓扑结构\n4. 外部服务，及其版本和配置信息\n5. 现有的数据及其他信息\n**高效管理环境策略原则**\n1. 二进制文件与配置信息分离\n2. 配置信息保存在一处\n\n\n## Part 3 持续集成\n**要求**：每当有人提交代码时，就对整个应用进行构建，并对其执行全面的自动化测试集合\n**目标**：让正在开发的软件一直处于可工作状态\n\n### 实现持续集成\n1. 准备工作\n\t1. 版本控制\n\t2. 自动化构建【命令行构建的重要性】\n\t3. 团队共识\n2. 持续集成工具\n\t1. 知道那里寻找代码控制库\n\t2. 运行什么脚本进行编译&自动化测试\n\t3. 如果提交破坏了程序，应该如何提醒 \n3. 基本的持续集成过程\n\t1. 确认上一次提交构建已成功\n\t2. 更新代码到本地\n\t3. 本地运行构建&测试，并确认能成功\n\t4. 提交代码到版本库\n\t5. 确认本次提交构建成功\n\n### 持续集成的前提条件\n1. 频繁提交【小步修改】\n2. 全面的自动化测试套件：单元测试、组件测试、验收测试\n3. 较短的构建和测试过程\n4. 开发环境管理\n\n### 持续集成软件\n**基本功能**：轮询版本控制系统、可视化\n\n### 必须的实践\n1. 构建失败之后不要提交新代码\n2. 提交前在本地运行所有的提交测试，或者让持续集成服务器完成此事\n3. 等提交测试通过后再继续工作\n4. 回家之前，构建必须处于成功状态\n5. 时刻准备着回滚到前一个版本\n6. 回滚之前要规定一个修复时间\n7. 不要将失败的测试注释掉\n8. 为自己导致的问题负责\n9. 测试驱动开发 TDD\n\n### 推荐的实践\n1. 极限编程【持续集成是极限编程的十二个核心实践之一】：TTD、代码集体所有权、重构...\n2. 若违背架构原则，就让构建失败\n3. 若测试运行变慢，就让构建失败\n4. 若有编译警告或代码风格问题，就让测试失败\n\n### 分布式团队 61~66\n\n\n## Part 4 测试策略 \n\n推荐阅读：《Agile Testing》\n\n测试策略的设计主要是**识别**和**评估**项目风险的优先级，以及决定采用哪些行动来缓解风险的一个过程。\n\n关键在于**建立最短反馈环**，于是**自动化测试**成为关键，但还需要结合手工测试\n\n### 测试分类\n\n测试象限 P68 图4-1\n\n两个维度：\n1. 业务导向 or 技术导向\n2. 支持开发过程 or 评判项目\n\n#### 业务导向 and 支持开发过程\n1. 功能测试／验收测试\n**目的**：确保用户故事的验收条件得到满足\n**范围**：功能、容量、易用性、安全性、可变性、可用性\n**分析**：Happy Path & Alternate Path & Sad Path、等价划分分析 & 边界值分析\n**环境**：类生产环境【尽可能保证和生产环境相似】\n**外部服务**：模拟[mock]技术\n**自动化验收测试**\n- 加快反馈速度\n- 减少测试人员负担\n- 回归测试 \n- 需求文档\n\n#### 技术导向 and 支持开发过程\n1. 单元测试\n**目的**：单独测试一个特定的代码段\n**范围**：不包括数据库、文件系统、外部系统，不包括组件之间的交互，覆盖每个代码分支路径\n2. 组件测试\n**目的**：测试相对更大的功能集合\n**范围**：需要连接数据库、文件系统或其他系统\n3. 部署测试\n**目的**：检查部署过程是否正常，即应用程序是否被正确的安装、配置，是否能与所需的服务正常通信，并得到回应\n\n#### 业务导向 and 评价项目\n1. 手工测试\n**目的**：验证我们实际交付给用户的应用软件是否符合其期望\n**方式**：演示(迭代完成时)\n2. 探索性测试\n**目的**：覆盖新需求\n3. 易用性测试\n**目的**：验证用户是否能很容易的使用该应用完成工作\n**方式**：情景调查\n4. Beta 测试：让真正用户使用\n\n#### 技术导向 and 评价项目\n1. 功能测试\n2. 非功能测试\n**目的**：测试功能之外的系统其它方面质量的测试，如容量、可用性、安全性\n\n#### 测试替身\n自动化测试中，运行时用一个模拟对象来代替系统中的一部分，以便于被测试的那部分和系统其它部分的交互被严格地掌控，从而更容易确定这一特定部分的行为。\n1. 哑对象 dummy object 被传递但不真正被使用的对象，常作为填充参数\n2. 假对象 fake object 可以真正使用，但是通常会利用捷径，不适合在生产环境使用，如内存数据库\n3. 桩 stub 为每个调用提供一个封装好的响应，只用于测试\n4. spy 一种科技路一些关于它们如何被调用的信息的桩\n5. 模拟对象 mock 在编程时就设定了它预期要接受的调用\n\n### 实践\n\n#### 新项目\n流程定义：\n1. 客户、分析师、测试人员定义验收条件\n2. 测试和开发人员一起基于验收条件实现验收测试的自动化\n3. 开发人员编码来满足验收条件\n4. 自动化测试失败，开发人员应该把它定位高优先级并修复它\n\n#### 项目进行中\n选取应用程序中那些最常见、最重要且高价值的用例为起点。进行所有 Happy Path 的测试。\n\n#### 遗留系统\n1. 覆盖核心功能的冒烟测试\n2. 自动化测试分层\n3. 只写有价值的自动化测试\n\n#### 集成测试\n1. 隔离\n2. 测试用具\n\n### 流程\n管理待修复缺陷列表\n1. 可视化\n2. 向对待功能特性一样来对待缺陷\n3. 缺陷分级：严重、阻塞、中、低\n\n=================== **部署流水线** ======================\n\n## Part 5 部署流水线解析\n\n**部署流水线**是指软件从版本控制库到用户手中这一过程的自动化表现形式。\n\n1. 提交阶段：从技术角度上断言整个系统是可以工作的；工作内容包括**编译**、**单元级别自动化测试**、**代码分析**\n2. 自动化验收测试阶段：从功能和非功能角度断言整个系统是可以工作的，即从系统行为看，它满足用户的需要且符合客户的需求规范\n3. 手工测试阶段：断言系统是可用的，满足系统要求，试图发现自动化测试未能捕获的缺陷，并验证是否为用户提供了价值；工作内容包括**探索性测试**、**集成环境测试**、**UAT测试**\n4. 发布阶段：将软件交付给用户\n\n### 实践建议\n\n1. 只生成一次二进制包【提交阶段】\n原因：避免引入编译结果不一致的风险，并且节省编译时间\n2. 对不同环境采用同一部署方式\n原因：避免部署方式区别导致的部署失败\n3. 对部署进行冒烟测试\n4. 向生产环境的副本中部署\n5. 每次变更都要立即在流水线中传递\n6. 只要有环节失败，就停止整个流水线\n\n#### 提交阶段\n\n1. 编译代码\n2. 运行一套提交测试\n3. 为后续阶段创建二进制包\n4. 执行代码分析来检查弟阿玛的健康状况\n5. 为后续阶段做准备工作，如准备测试数据库\n\n**一些代码健康度量**：\n\n- 测试覆盖率\n- 重复代码数量\n- 圈复杂度\n- 输入耦合度 and 输出耦合度\n- 编译警告数量\n- 代码风格\n\n#### 测试阶段\n\n1. 自动化验收测试\n2. 其它\n\n#### 发布准备\n\n1. 自动部署与发布\n2. 变更的撤销\n3. 在成功的基础上构建\n\n#### 实现\n\n### 度量\n\n## Part 6：构建和部署的脚本化\n\n## Part 7: 提交阶段\n\n**目标**\n\n1. 创建可部署的产物\n2. 快速失败并将失败原因通知给团队\n\n### 快速有用的反馈\n\n**提交测试失败的主要原因**\n\n1. 语法错误导致编译失败\n2. 语义错误导致测试失败\n3. 应用程序配置或环境方面的问题\n\n**构建负责人**\n\n\n\n## Part 8: 自动化验收测试\n\n## Part 9: 非功能需求的测试\n\n## Part 10: 应用程序的部署与发布\n\n------------------- 交付生态圈 ---------------------\n\n## Part 11: 基础设施与环境管理\n\n## Part 12: 数据管理\n\n## Part 13: 组件和依赖管理\n\n## Part 14: 版本控制进阶\n\n## Part 15: 持续交付管理\n\n","tags":["Project Management"]},{"title":"CSS Grid","url":"/2018/08/10/CSS-Grid/","content":"\nCSS Grid 学习集合：\n- <https://medium.com/deemaze-software/css-grid-responsive-layouts-and-components-eee1badd5a2f>\n","tags":["CSS"]},{"title":"Element You Never Know","url":"/2018/08/10/Element-You-Never-Know/","content":"\n收集一些神奇但不常用的 HTML 标签，了解其存在的原因，使用场景，并尝试更多得使用它！\n\nLink：<https://developer.mozilla.org/en-US/docs/Web/HTML/Element>\n","tags":["HTML"]},{"title":"Problem Solving","url":"/2018/08/10/Problem-Solving/","content":"\n程序思维解决问题：\n1. 理解问题：写下你的问题，图形化，向别人【其他媒介】简要地讲述这个问题【小黄鸭调试法】\n2. 有计划地解决问题：写下具体步骤，并思考\"Given input X, what are the steps necessary to return output Y?\"\n3. 任务拆分\n\n一些技巧：\n1. Debug: 理解程序地实际运行流程，而不是你认为程序地运行流程\n2. Reassess： \n","tags":["Other"]},{"title":"Web Architecture","url":"/2018/08/10/Web-Architecture/","content":"\n![Web_Architecture](/imgs/web-architecture.png)\n","tags":["FullStack"]},{"title":"Exploring ES2018 and ES2019 之 Asynchronous iteration","url":"/2018/08/09/Exploring-ES2018-and-ES2019-1/","content":"\n这是一个学习系列笔记，来源于学习《Exploring ES2018 and ES2019》，电子书地址：<http://exploringjs.com/es2018-es2019/toc.html>\n","tags":["ES2018"]},{"title":"构建系列-FIS 3","url":"/2018/08/09/Build-FIS-3/","content":"\nFIS 3是一个来自百度的优秀国产构建工具。   \n相比Grant、Gulp只提供了基本的功能的工具，FIS 3提供了一些常见的前端构建功能：\n\n- 读写文件：通过 fis.match 读文件，release 配置文件输出路径。\n- 资源定位：解析文件之间的依赖关系和文件位置。\n- 文件指纹：在通过 useHash 配置输出文件时为文件 URL加上 md5 戳，来优化浏览器的缓存。\n- 文件编译：通过 parser 配置文件解析器做文件转换，例如将 ES6 编译成 ES5。\n- 压缩资源：通过 optimizer 配置代码压缩方法。\n- 图片合并：通过 spriter 配置合并 CSS 里导入的图片到一个文件中，来减少 HTTP 请求数。","tags":["Build"]},{"title":"构建系列-Gulp","url":"/2018/08/09/Build-Gulp/","content":"\nGulp 是一个基于流的自动化构建工具。除了可以管理任务和执行任务，还支持监听文件、读写文件。支持以下5个方法：\n\n- 通过 gulp.task 注册一个任务；\n- 通过 gulp.run 执行任务；\n- 通过 gulp.watch 监听文件变化；\n- 通过 gulp.src 读取文件；\n- 通过 gulp.dest 写完文件。","tags":["Build"]},{"title":"构建系列-What","url":"/2018/08/09/Build-What-to-do/","content":"\n前端工程化思想的技术落地，将源代码转换成可以执行的JavaScript、CSS、HTML 代码，具体包括：\n\n1. 代码转换：将 TypeScript 编译成JavaScript、将 SCSS 编译成 CSS等。\n2. 文件优化：压缩JavaScript、CSS、HTML 代码，压缩合并图片等。\n3. 代码分割：提取多个页面的公共代码，提取首屏不需要执行部分代码让其异步记在。\n4. 模块合并：在采用模块化的项目里会有很多个模块和文件，需要通过构建功能将模块分类合并成一个文件。\n5. 自动刷新：监听本地源代码变化，自动重新构建、刷新浏览器。\n6. 代码校验：在代码被提交到仓库前需要校验代码是否符合规范，以及单元测试是否通过。\n7. 自动发布：更新代码后，自动构建出线上发布代码并传输给发布系统。","tags":["Build"]},{"title":"CSS 7-1 Pattern","url":"/2018/08/09/Css-7-1-pattern/","content":"\n1. 7 different folders\n    1. base：typography rules, animations, utilities···\n    2. components：buttons, forms, swipers, popups···\n    3. layout：header, footer, navigation, section，grid···\n    4. pages：special style for page only\n    5. themes：different themes\n    6. abstracts：functions & helpers，variables and mixins\n    7. vendors：third part css，like bootstrap···\n2. 1 main.scss file to import all other files\n","tags":["CSS"]}]