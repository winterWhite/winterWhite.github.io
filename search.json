[{"title":"Software Architectural Pattern","url":"/2018/08/13/Software-Architectural-Pattern/","content":"\n## Layered pattern 分层模式\n\n基础分层：\n1. Presentation layer (UI layer) 表现层\n2. Application layer (Service layer) 应用层\n3. Business logic layer (Domain layer) 业务层\n4. Data access layer (Persistence layer) 数据层\n\n应用场景：\n1. General desktop applications 桌面应用程序\n2. E commerce web applications 电子商务 Web 应用\n\n示意图：\n\n![Layered pattern](/imgs/architectural-pattern-layered.png)\n\n\n## Client-server pattern 客户端／服务器模式\n\n服务器监听客户端的所有请求，并进行响应\n\n应用场景：\n1. Online applications 线上应用，如 email、banking\n\n示意图：\n\n![Client-server pattern](/imgs/architectural-pattern-c-s.png)\n\n\n## Master-slave pattern 主从模式\n\nMaster 分发工作到 Slaves 的工作模式\n\n应用场景：\n1. Database replication 数据库复制中的主数据库和从属数据库\n2. Master and Slave drives 主／从驱动器\n\n示意图：\n\n![Master-slave pattern](/imgs/architectural-pattern-m-s.png)\n\n\n## Pipe-filter pattern 管道过滤器模式\n\n数据 filtering 模式\n\n应用场景：\n1. Compilers 编译器\n2. Workflows in bioinformatics 生物信息学工作流程\n\n示意图：\n\n![Pipe-filter pattern](/imgs/architectural-pattern-p-f.png)\n\n\n## Broker pattern 经纪人模式\n\n分布式系统，服务端-代理-客户端模式\n\n应用场景：\n1. Message broker software 消息代理软件，如 Apache Kafka\n\n示意图：\n\n![Broker pattern](/imgs/architectural-pattern-broker.png)\n\n\n## Peer-to-peer pattern 点对点模式\n\n对等体，同时具有服务端／客户端的角色功能，可动态切换\n\n应用场景：\n1. File-sharing networks 文件共享网络，如 G2\n2. Multimedia protocols 多媒体协议，如 P2PTV\n\n示意图：\n\n![Peer-to-peer pattern](/imgs/architectural-pattern-p2p.png)\n\n\n## Event-bus pattern 事件总线模式\n\n事件的4个组成部分：Event Source 事件源、Event Listener 事件监听器、Channel 通道、Event Bus 事件总线\n\n应用场景：\n1. Android development 安卓开发\n2. Notification services 通知服务\n\n示意图：\n\n![Event-bus pattern](/imgs/architectural-pattern-e-b.png)\n\n\n## Model-view-controller pattern 模型-视图-控制器模式 (MVC)\n\n3个组成部分：\n1. Model: Core functionality and data\n2. View: Displays the information to the user\n3. Controller: Handles the input from the user\n\n解耦数据与用户展示\n\n应用场景：\n1. World Wide Web applications 万维网应用架构\n2. Web frameworks Web 框架，如 Rails\n\n示意图：\n\n![Model-view-controller pattern](/imgs/architectural-pattern-mvc.png)\n\n\n## Blackboard pattern 黑板模式\n\n3个组成部分：\n1. blackboard \n2. knowledge source\n3. control component\n\n应用场景：\n1. Speech recognition 语音识别\n2. Vehicle identification and tracking 车辆识别与跟踪\n3. Protein structure identification 蛋白质结构鉴定\n4. Sonar signals interpretation 声纳信号解释\n\n示意图：\n\n![Blackboard pattern](/imgs/architectural-pattern-blackboard.png)\n\n\n## Interpreter pattern 口译员模式\n\n为语言的每个符号设定一个类，解释专用语言编写的程序组件\n\n应用场景：\n1. Database query languages 数据库语言，如 SQL\n2. Languages used to describe communication protocols 描述通信协议的语言\n\n示意图：\n\n![Interpreter pattern](/imgs/architectural-pattern-Interpreter.png)\n\n\n## Compare 对比\n\n![Compare architectural pattern](/imgs/architectural-pattern-compare.png)\n\n","tags":["BackEnd"]},{"title":"Continuous Delivery","url":"/2018/08/13/Continuous-Delivery/","content":"\n# 《持续交付-发布可靠软件的系统方法》\n\n## Part 1 基础篇\n\n### 软件交付的问题\n\n**关键词**：\n部署流水线：构建 => 部署 => 测试 => 发布\n自动化、持续集成\n\n**发布反模式**\n1. 手工部署\n2. 开发完成之后才向类生产环境部署\n3. 生产环境的手工配置管理\n\n**关键词**：短周期【决定变更～用户可用】、高质量【质量不等于完美】\n反馈：\n1. 无论什么样的修改都应该触发反馈流程\n2. 反馈应该尽快发出\n3. 交付团队必须接受反馈，并依据它做出相应的行动\n\n可工作的软件组成：可执行的代码、配置信息、运行环境、数据\n\n**软件交付原则**\n1. 为软件发布创建一个**可重复**且**可靠**的过程\n\t1. 尽可能地自动化\n\t2. 尽可能将所有东西纳入版本控制\n2. 内建质量：尽早发现问题，解决问题，提前并频繁地做让你感到痛苦的事\n3. DONE意味着“已发布”\n4. 交付过程事每个成员的责任\n5. 持续改进: 计划plan => 做do => 研究stydy => 行动act\n\n\n## Part 2 配置管理\n\n### 定义\n**配置管理**：配置管理是指一个过程，通过该过程，所有与项目相关的产物，以及它们之间的关系都被**唯一**定义、修改、存储和检索\n\n### 版本控制\n**版本控制系统**：也称源代码控制管理系统或修订控制系统，是保存文件多个版本的一种机制。example：SCCS、RCS、CVS、Subversion、Mercurial、Git...\n\n**版本控制的目的**\n1. 保留每个文件的所有版本的历史信息，并使之易于查找\n2. 让分布式团队可以愉快地协作\n\n#### 与项目相关的所有东西都纳入版本控制\n**目标**：能够随时获取软件在整个生命周期中任意时间点的文件状态【编译后的二进制代码不需要】\n\n#### 频繁提交\n1. 只有频繁提交代码，才能享受版本控制带来的好处\n2. 一旦将代码提交，团队的所有人都能看到这些变更\n3. 一次提交出发一次构建集成\n\n提交需要确保不破坏原有系统：\n1. 提交代码前运行测试套件\n2. 增量式引入变化\n\n当进行某项复杂的工作时，如何保证频繁提交的同时又不破坏原有系统？\n\n**不推荐开分支的原因**\n1. 违背了持续集成的宗旨，新分支推迟了新功能的整合，只有到分支被合并时才能发现集成问题\n2. 多个开发者分别创建分支，问题会程指数增加，合并过程也会极其复杂\n3. 尽管又好用的自动合并功能，但它无法解决语义冲突\n4. 合并困难导致重构代码库变得困难\n\n我们推荐使用**增量方式**开发新功能，并频繁且有规律地向版本控制系统提交代码。\n\n#### 提交注释\n推荐的提交注释：第一段简短地总结性描述；接下来描述更多细节；包含一个可以链接到项目管理工具中的一个功能或缺陷的链接\n\n### 依赖管理\n1. 外部库文件\n2. 组件管理\n\n### 软件配置管理\n配置反模式：终级配置，系统配置工作变得非常复杂以至于抵消了其在灵活性上带来的好处\n**更好的方式**：先专注于提供具有高价值且可配置程度较低的功能，然后在真正需要时再添加可配置选项\n\n#### 配置分类\n1. 构建时\n2. 打包时\n3. 部署软件程序时\n4. 启动／运行时\n建议：在相邻的两次部署之间，任何变更都应该作为配置项被捕获和记录，而不应该在编译或打包时植入\n\n#### 应用程序配置管理\n特定于测试环境或生产环境的实际配置信息应该与源代码分离在单独的代码库中。需要保证配置信息的版本与相应的应用软件的版本相匹配。\n\n1. 获取配置信息\n\t1. 中央服务系统提供配置信息\n\t2. 中心仓库获取配置信息\n2. 配置项建模\n3. 系统配置测试\n\t1. 保证配置设置中对外部服务的饮用是良好的\n\t2. 冒烟测试\n\n**跨应用配置管理**：配置选项索引表、实时存取配置信息\n\n#### 管理配置信息的原则\n将应用程序的配置信息当作代码一样来看待 \n1. 明确配置注入时机\n2. 配置项与代码同一个仓库保存，但配置值单独保存\n3. 自动化\n4. 容易查看\n5. 明确命名\n6. 模块化 and 封闭\n7. DRY 原则\n8. 最少化\n9. 避免过度设计，应尽可能简单\n10. 测试\n\n### 环境管理\n**环境**：应用程序所以来的硬件、软件、基础设施和外部系统\n**原则**：环境的配置和应用程序的配置同样重要\n**内容**\n1. 操作系统，包括其版本、补丁级别以及配置设置\n2. 软件包，及软件包的具体版本和配置\n3. 网络拓扑结构\n4. 外部服务，及其版本和配置信息\n5. 现有的数据及其他信息\n**高效管理环境策略原则**\n1. 二进制文件与配置信息分离\n2. 配置信息保存在一处\n\n\n## Part 3 持续集成\n**要求**：每当有人提交代码时，就对整个应用进行构建，并对其执行全面的自动化测试集合\n**目标**：让正在开发的软件一直处于可工作状态\n\n### 实现持续集成\n1. 准备工作\n\t1. 版本控制\n\t2. 自动化构建【命令行构建的重要性】\n\t3. 团队共识\n2. 持续集成工具\n\t1. 知道那里寻找代码控制库\n\t2. 运行什么脚本进行编译&自动化测试\n\t3. 如果提交破坏了程序，应该如何提醒 \n3. 基本的持续集成过程\n\t1. 确认上一次提交构建已成功\n\t2. 更新代码到本地\n\t3. 本地运行构建&测试，并确认能成功\n\t4. 提交代码到版本库\n\t5. 确认本次提交构建成功\n\n### 持续集成的前提条件\n1. 频繁提交【小步修改】\n2. 全面的自动化测试套件：单元测试、组件测试、验收测试\n3. 较短的构建和测试过程\n4. 开发环境管理\n\n### 持续集成软件\n**基本功能**：轮询版本控制系统、可视化\n\n### 必须的实践\n1. 构建失败之后不要提交新代码\n2. 提交前在本地运行所有的提交测试，或者让持续集成服务器完成此事\n3. 等提交测试通过后再继续工作\n4. 回家之前，构建必须处于成功状态\n5. 时刻准备着回滚到前一个版本\n6. 回滚之前要规定一个修复时间\n7. 不要将失败的测试注释掉\n8. 为自己导致的问题负责\n9. 测试驱动开发 TDD\n\n### 推荐的实践\n1. 极限编程【持续集成是极限编程的十二个核心实践之一】：TTD、代码集体所有权、重构...\n2. 若违背架构原则，就让构建失败\n3. 若测试运行变慢，就让构建失败\n4. 若有编译警告或代码风格问题，就让测试失败\n\n### 分布式团队 61~66\n\n\n## Part 4 测试策略 \n\n推荐阅读：《Agile Testing》\n\n测试策略的设计主要是**识别**和**评估**项目风险的优先级，以及决定采用哪些行动来缓解风险的一个过程。\n\n### 测试分类\n\n测试象限 P68 图4-1\n\n两个维度：\n1. 业务导向 or 技术导向\n2. 支持开发过程 or 评判项目\n\n#### 业务导向 and 支持开发过程\n1. 功能测试／验收测试\n**目的**：确保用户故事的验收条件得到满足\n**范围**：功能、容量、易用性、安全性、可变性、可用性\n**分析**：Happy Path & Alternate Path & Sad Path、等价划分分析 & 边界值分析\n**环境**：类生产环境【尽可能保证和生产环境相似】\n**外部服务**：模拟[mock]技术\n**自动化验收测试**\n- 加快反馈速度\n- 减少测试人员负担\n- 回归测试 \n- 需求文档\n\n\n","tags":["Project Management"]},{"title":"Beatiful Library","url":"/2018/08/13/Beatiful-Library/","content":"\n## CSS\n\n- Semantic UI: <https://semantic-ui.com/>\n- CSS property 一览表：<https://css-tricks.com/almanac/>\n- Some Interesting Pure Css Animation: <https://webdesign.tutsplus.com/articles/pure-css-animation-inspiration-on-codepen--cms-30875>\n- Hover, an Css animation library: <http://ianlunn.github.io/Hover/>\n\n## JS\n\n- Anime animation library: <http://animejs.com/>\n- Lottie mobile animation library: <http://airbnb.io/lottie/>","tags":["Library"]},{"title":"CSS Grid","url":"/2018/08/10/CSS-Grid/","content":"\nCSS Grid 学习集合：\n- <https://medium.com/deemaze-software/css-grid-responsive-layouts-and-components-eee1badd5a2f>\n","tags":["CSS"]},{"title":"Element You Never Know","url":"/2018/08/10/Element-You-Never-Know/","content":"\n收集一些神奇但不常用的 HTML 标签，了解其存在的原因，使用场景，并尝试更多得使用它！\n\nLink：<https://developer.mozilla.org/en-US/docs/Web/HTML/Element>\n","tags":["HTML"]},{"title":"Problem Solving","url":"/2018/08/10/Problem-Solving/","content":"\n程序思维解决问题：\n1. 理解问题：写下你的问题，图形化，向别人【其他媒介】简要地讲述这个问题【小黄鸭调试法】\n2. 有计划地解决问题：写下具体步骤，并思考\"Given input X, what are the steps necessary to return output Y?\"\n3. 任务拆分\n\n一些技巧：\n1. Debug: 理解程序地实际运行流程，而不是你认为程序地运行流程\n2. Reassess： \n","tags":["Other"]},{"title":"Web Architecture","url":"/2018/08/10/Web-Architecture/","content":"\n![Web_Architecture](/imgs/web-architecture.png)\n","tags":["FullStack"]},{"title":"Exploring ES2018 and ES2019 之 Asynchronous iteration","url":"/2018/08/09/Exploring-ES2018-and-ES2019-1/","content":"\n这是一个学习系列笔记，来源于学习《Exploring ES2018 and ES2019》，电子书地址：<http://exploringjs.com/es2018-es2019/toc.html>\n","tags":["ES2018"]},{"title":"Career-Learning","url":"/2018/08/09/Career-Learning/","content":"\n## Front End\n\n![FrontEnd Learning RoadMap](/imgs/frontend.png)\n\n\n## Back End\n\n![BackEnd_Learning_RoadMap](/imgs/backend.jpg)\n\n\n## Devops\n\n![Devops_Learning_RoadMap](/imgs/devops.png)\n\n\n## React Dev\n\n![React_Learning_RoadMap](/imgs/react.png)","tags":["Career"]},{"title":"构建系列-FIS 3","url":"/2018/08/09/Build-FIS-3/","content":"\nFIS 3是一个来自百度的优秀国产构建工具。   \n相比Grant、Gulp只提供了基本的功能的工具，FIS 3提供了一些常见的前端构建功能：\n\n- 读写文件：通过 fis.match 读文件，release 配置文件输出路径。\n- 资源定位：解析文件之间的依赖关系和文件位置。\n- 文件指纹：在通过 useHash 配置输出文件时为文件 URL加上 md5 戳，来优化浏览器的缓存。\n- 文件编译：通过 parser 配置文件解析器做文件转换，例如将 ES6 编译成 ES5。\n- 压缩资源：通过 optimizer 配置代码压缩方法。\n- 图片合并：通过 spriter 配置合并 CSS 里导入的图片到一个文件中，来减少 HTTP 请求数。","tags":["Build"]},{"title":"构建系列-Webpack","url":"/2018/08/09/Build-Webpack/","content":"\nWebpack 是一个打包模块化的JavaScript的工具，专注于构建模块化的项目。   \nWebpack 通过 loader 转换文件，通过Plugin 注入钩子，最后输出由多个模块组合成的文件。\n","tags":["Build"]},{"title":"构建系列-Gulp","url":"/2018/08/09/Build-Gulp/","content":"\nGulp 是一个基于流的自动化构建工具。除了可以管理任务和执行任务，还支持监听文件、读写文件。支持以下5个方法：\n\n- 通过 gulp.task 注册一个任务；\n- 通过 gulp.run 执行任务；\n- 通过 gulp.watch 监听文件变化；\n- 通过 gulp.src 读取文件；\n- 通过 gulp.dest 写完文件。","tags":["Build"]},{"title":"构建系列-What","url":"/2018/08/09/Build-What-to-do/","content":"\n前端工程化思想的技术落地，将源代码转换成可以执行的JavaScript、CSS、HTML 代码，具体包括：\n\n1. 代码转换：将 TypeScript 编译成JavaScript、将 SCSS 编译成 CSS等。\n2. 文件优化：压缩JavaScript、CSS、HTML 代码，压缩合并图片等。\n3. 代码分割：提取多个页面的公共代码，提取首屏不需要执行部分代码让其异步记在。\n4. 模块合并：在采用模块化的项目里会有很多个模块和文件，需要通过构建功能将模块分类合并成一个文件。\n5. 自动刷新：监听本地源代码变化，自动重新构建、刷新浏览器。\n6. 代码校验：在代码被提交到仓库前需要校验代码是否符合规范，以及单元测试是否通过。\n7. 自动发布：更新代码后，自动构建出线上发布代码并传输给发布系统。","tags":["Build"]},{"title":"CSS 7-1 Pattern","url":"/2018/08/09/Css-7-1-pattern/","content":"\n1. 7 different folders\n    1. base：typography rules, animations, utilities···\n    2. components：buttons, forms, swipers, popups···\n    3. layout：header, footer, navigation, section，grid···\n    4. pages：special style for page only\n    5. themes：different themes\n    6. abstracts：functions & helpers，variables and mixins\n    7. vendors：third part css，like bootstrap···\n2. 1 main.scss file to import all other files\n","tags":["CSS"]}]